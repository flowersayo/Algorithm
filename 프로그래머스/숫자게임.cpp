#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

/**
[숫자 게임]
https://school.programmers.co.kr/learn/courses/30/lessons/12987

가장 직관적으로 떠오른 것은 그리디 풀이
=> 그 때 그 때마다 이길 수 있는 패를 내면 된다.

Q. 지금 이기는 걸 포기하고 똥패를 내고 큰 수를 아껴서 이득을 보는 경우가 있을 수도 있지 않는가?

A. 만약 지금 내는 걸 포기하고 큰 수를 아꼈다고 해보자. 나올 수 있는 상황은 두가지이다.
1. 나의 큰 수를 아껴서 상대방의 더 큰 수를 이길 수 있게 되는 경우.
2. 운이 좋지 않으면 뒤쪽에 내가 아낀 큰수로 이길 수 있는 수가 나오지 않는다.

사실 극심한 차이(1<9) 로 이기나, 간소한 차이로(8<9) 이기나
둘다 같은 1승이라는 것에는 차이가 없으므로 이길 수 있을 때 이기는 것이 최선이다!

최대한 작은수로 이길 수 있으면 다음 턴에 더 큰수를 이길 수 있는 확률이 높아지므로,
해당 상대 카드를 이길 수 있는 패 중에 가장 작은 수를 골라서 내면 된다.
이를 구현하기 쉽게 하기 위해서 상대방에 카드에 대해 내가 어떤 패를 낼 것 인가 가 아니라
"내가 가지고 있는 패로 이길 수 있는 상대의 패 하나를 정한다." 라는 관점에서 접근한다.

두 덱 모두 오름차순 정렬을 해두면
상대방의 카드 하나에 대해서 매번 내 모든 덱을 뒤져서 이길 수 있는 패를 찾지 않아도 된다.
이후에 나올 상대방의 카드는 지금 보다 더 큰 수일테이므로,
항상 내가 마지막에 낸 패 보다 큰 수 중에서 찾아보면 된다.

*/
int solution(vector<int> A, vector<int> B)
{
    int answer = 0;

    sort(A.begin(), A.end()); // 오름차순
    sort(B.begin(), B.end()); // 오름차순

    int target_idx = 0; // 상대방의 카드
    for (int i = 0; i < B.size(); i++)
    {

        if (B[i] > A[target_idx])
        {
            target_idx++;
            answer++;
        }
    }
    return answer;
}